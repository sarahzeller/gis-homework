---
author: Sarah Zeller
title: Homework assignment 2
subtitle: Predicting building antennas in Tanzania
format:
  html: 
    toc: true
    mainfont: "Open Sans"
  pdf:
    toc: true
    number-sections: true
    mainfont: "Open Sans"
    include-in-header: 
      - text: |
          % f√ºr Alignment bei Kommastelle
          \usepackage{booktabs}
          \usepackage{siunitx}
          % alle Tabellen kleiner setzen
          \usepackage{etoolbox}
          \AtBeginEnvironment{longtable}{\footnotesize}
          \AtBeginEnvironment{tabular}{\footnotesize}
          \sisetup{group-separator       = {,}, % default: \, ("thinspace")
                  group-minimum-digits  = 3,   % default: 5
                  input-decimal-markers = {.}} % default: "{.,}"
execute:
  warning: false
  echo: false
bibliography: references.bib
editor: 
  markdown: 
    wrap: sentence
---

{{< pagebreak >}}

In this report, I'm having a look at cell phone towers in Tanzania, and estimate the probability of them being built in a certain area.
I first describe the region and variables.
I then show my regression and discuss them.

```{r}
#| label: install-packages
#| echo: false
#| output: false
#| warning: false
#| eval: false

if (!require("remotes")) install.packages("remotes", quiet = TRUE)
if (!require("rnaturalearthhires")) {
  remotes::install_github("ropensci/rnaturalearthhires")
} 
if (!require("renv")) install.packages("renv", quiet = TRUE)
renv::hydrate()
```

```{r}
#| label: load-packages
library(here)
library(archive)
library(sf)
library(mapview)
library(ggtext)
library(tidyverse)
library(rnaturalearth)
library(rnaturalearthhires)
library(osmdata)
library(nngeo)
library(modelsummary)
library(kableExtra)
library(labelled)
library(fixest)
library(stars)
library(raster)
library(dplyr)

library(showtext)
font_add_google("Open Sans")
showtext_auto()


here("run_regressions_hw-2.R") |> source()
here("show_regressions_hw-2.R") |> source()

```

```{r}
#| label: check-for-output-folder
if (!"output" %in% (here() |> list.files())) {
  here("output") |> dir.create()
}
```

# Project region

Before diving into the details, let's have a look at the region I am talking about.
@fig-locator-map shows where in the world our country of interest lies, while @fig-basemap shows some political details.
Tanzania lies in Eastern Africa, with its coast towards the Indian Ocean.
It is divided into 30 states.

```{r}
#| label: load-tanzania

tanzania_whole <- ne_countries(country = "United Republic of Tanzania",
                               scale = 10,
                               returnclass = "sf") 

tanzania <- ne_states(country = "United Republic of Tanzania",
                      returnclass = "sf") 

# write shape file and zip it
if (!("tanzania" %in% (here("output") |> list.files()))) {
  here("output/tanzania") |> dir.create()
  st_write(tanzania |> dplyr::select(name, geometry),
           here("output/tanzania/tanzania.shp")) |> try()
  
  zip(here("output/tanzania.zip"),
      here("output/tanzania"))
}

tanzania_vect <- here("output/tanzania/tanzania.shp") |> terra::vect()

```

```{r}
#| label: fig-locator-map
#| fig-cap: Research area is located in Tanzania.

world <- ne_countries(scale = "small",
                      returnclass = "sf") |> 
  st_cast('MULTILINESTRING') |> 
  st_cast('LINESTRING', do_split = TRUE) |> 
  mutate(npts = npts(geometry, by_feature = TRUE)) |> 
  st_cast('POLYGON')

ggplot() +
  geom_sf(data = world,
          aes(fill = sovereignt == "United Republic of Tanzania")) +
  scale_fill_manual(values = c("grey90",
                               "#1EB53A")) +
  guides(fill = FALSE) +
  coord_sf(crs = "+proj=ortho +lat_0=5 +lon_0=-10") +
  labs(caption = "Data: Natural Earth") +
  theme_void() +
  theme(text = element_text(family = "Open Sans"))

```

```{r}
#| label: fig-basemap
#| fig-cap: Political map of Tanzania

bounds <- st_bbox(tanzania_whole |> st_transform("ESRI:102022") |> st_buffer(100000))

africa <- ne_countries(continent = "africa",
                       scale = 10,
                       returnclass = "sf") |> 
  st_transform("ESRI:102022") |> 
  st_crop(bounds) |> 
  st_transform(4326)

basemap <- 
  ggplot() +
  geom_sf(data = africa,
          fill = "grey90",
          col = "grey80") +
  scale_x_continuous(expand = c(0,0)) +
  scale_y_continuous(expand = c(0,0)) +
  geom_sf(data = tanzania,
          fill = "white",
          col = "grey70") +
  annotate("text",
           label = "Indian \nOcean",
           x = 40.5,
           y = -7,
           size = 3,
           lineheight = .75,
           colour = "grey40") +
  theme_void() +
  theme(panel.background = element_rect(fill = alpha("cornflowerblue", .4),
                                        colour = NA),
        plot.margin = margin(-10,0,0,0),
        text = element_text(family = "Open Sans")) +
  labs(caption = "Data: Natural Earth")

basemap
```

# Data sources


## Nighttime lights

I access nighttime lights from the file uploaded in OPAL.

```{r}
#| label: load-nightlights

if (! "nightlights_sf.rds" %in% (here("output") |> list.files())) {
  nightlights <- here("input/DN_NTL_2021.tif") |>
    raster::raster() |>
    crop(tanzania_whole) |>
    mask(tanzania_whole)
  
  nightlights_sf <- nightlights |>
    # as('SpatialPolygonsDataFrame') |> 
    rasterToPolygons(dissolve = FALSE, na.rm = TRUE) |> 
    st_as_sf()
  
  saveRDS(nightlights_sf,
          here("output/nightlights_sf.rds"))
  st_write(nightlights_sf,
           here("output/nightlights_sf.shp")) |> try()
} else {
  nightlights_sf <- here("output/nightlights_sf.rds") |> readRDS()
}

nightlights_terra <- here("input/DN_NTL_2021.tif") |> 
  terra::rast() |> 
  # crop to extent
  crop(tanzania_whole) |> 
  # clip exact borders
  mask(tanzania_whole)

nightlights_vect <- here("output/nightlights_sf.shp") |> terra::vect()

```

```{r}
#| label: fig-nightlights-zonal
#| fig-cap: 
#|   - Nightlights (zonal)
#|   - Nightlights

nightlights_zonal <- zonal(nightlights_terra, tanzania_vect, fun = "mean", na.rm = TRUE) |> 
  cbind(tanzania |> dplyr::select(name)) |> 
  st_as_sf()

basemap + 
  geom_sf(data = nightlights_zonal,
          aes(fill = log(DN_NTL_2021))) +
  labs(fill = "Log night time lights")

basemap +
  geom_raster(data = nightlights_terra |> as.data.frame(xy = TRUE),
              aes(x = x,
                  y = y,
                  fill = DN_NTL_2021))

```




## Mobile antennas

The presence of a mobile antenna is what we want to predict.
I remove all observations after 2022, since the data for 2023 are not complete yet.
I split the data into three data sets:

-   2G (GSM technology)
-   3G (UMTS technology)
-   4G (LTE technology)

```{r}
#| label: load-cellid
here("input/opencellid_tanzania.RData") |> load()

open_cell <- opencellid_tanzania |> 
    # convert to sf 
  st_as_sf(coords = c("lon", "lat"),
           crs = 4326) |> 
  filter(created_year <= 2022) |> # complete years
  mutate(across(c(created, updated), as_datetime)) |> 
  mutate(created_year = year(created) |> as.integer(),
         create_month = month(created)) |> 
  # order 2G/3G/4G
  mutate(radio = factor(radio, 
                        levels = c("GSM", "UMTS", "LTE"), 
                        ordered = TRUE))|> 
  # add state and subset for only antennas within known states
  st_intersection(tanzania |> transmute(state = name)) 

two_g <- open_cell |> filter(radio == "GSM")
three_g <- open_cell |> filter(radio == "UMTS")
four_g <- open_cell |> filter(radio == "LTE")

```

```{r}
#| label: fig-antennas
#| fig-cap: Mobile network antennas in Tanzania

basemap +
  geom_sf(data = open_cell |> st_jitter(),
          size = .8,
          alpha = .4) +
  facet_wrap(~radio) +
  labs(caption = "Data: Open Cell ID")
```



## Lightnings

I include the lightning data I used last time.
Originally, it was a raster file, so this approach seems justified.

```{r}
#| label: load-lightning
here("input/lightnings_2014.rds") |> readRDS() |> 
  # only retain rasters for Tanzania
  st_intersection(tanzania_whole |> dplyr::select(geometry)) |> 
  dplyr::select(lightnings_mean_2014) |> 
  stars::st_rasterize() |> 
  write_stars(here("output/lightnings_tanzania.tif"))

lightning <- here("output/lightnings_tanzania.tif") |> 
  terra::rast() |> 
  # clip exact borders
  mask(tanzania_whole)
```

```{r}
#| label: fig-lightning
#| fig-cap: Lightning frequencies in Tanzania

basemap +
  geom_raster(data = lightning |> as.data.frame(xy = TRUE),
          aes(fill = lightnings_tanzania,
              x = x,
              y = y)) +
  labs(fill = "Average lightnings \nin 2014")

```

## Terrain ruggedness (TRI)

I download terrain ruggedness index (TRI) data from the [Harvard Dataverse](https://dataverse.harvard.edu/dataset.xhtml;jsessionid=f1ff7041fae2752fa64ab754bc0e?persistentId=doi%3A10.7910%2FDVN%2FWXUZBN&version=&q=&fileTypeGroupFacet=%22Document%22&fileAccess=&fileTag=&fileSortField=&fileSortOrder=#) [@carter].
Since the download link changes every time I added the downloaded folder to the input folder.

```{r}
#| label: load-tri

# extract zip
if(!("tri_tanzania.tif" %in% (here("output") |> list.files()))) {
  archive_extract(here("input/dataverse_files.zip"),
                  here("output/tri"))
  
  # crop raster to Tanzania
  here("output/tri/Ruggedness_OneKilometerData/ruggedness1K.tif") |>
    raster::raster() |>
    raster::crop(tanzania_whole |> st_transform("ESRI:54010")) |>
    mask(tanzania_whole |> st_transform("ESRI:54010")) |>
    raster::writeRaster(here("output/tri_tanzania.tif"), overwrite = TRUE)
}

# read in
tri <- here("output/tri_tanzania.tif") |> 
  terra::rast() |> 
  terra::project("epsg:4326")

```

```{r}
#| label: fig-zonal-tri
#| fig-cap: 
#|    - TRI for Tanzanian states
#|    - TRI

tri_zonal <- zonal(tri, 
                   tanzania_vect, 
                   fun = "mean",
                   na.rm = TRUE)  |> 
  cbind(tanzania |> dplyr::select(name)) |> 
  st_as_sf()

basemap + 
  geom_sf(data = tri_zonal,
          aes(fill = tri_tanzania)) +
  labs(fill = "Terrain Ruggedness \nIndex",
       caption = "Data: Harvard Dataverse")

basemap +
  geom_raster(data = tri |> as.data.frame(xy = TRUE),
              aes(x = x,
                  y = y,
                  fill = tri_tanzania)) +
  labs(fill = "Terrain Ruggedness \nIndex",
       caption = "Data: Harvard Dataverse")
  
```

## Global Human Settlement Layer (GHSL)

The data for the Global Human Settlement Layer come from the European Commission.
I download them on a 250m grid with data from 2014.

```{r}
#| label: download-ghsl

if (! ("ghsl.tif" %in% (here("output") |> list.files()))) {
  # download
  download.file("http://cidportal.jrc.ec.europa.eu/ftp/jrc-opendata/GHSL/GHS_BUILT_LDSMT_GLOBE_R2015B/GHS_BUILT_LDS2014_GLOBE_R2016A_54009_250/V1-0/GHS_BUILT_LDS2014_GLOBE_R2016A_54009_250_v1_0.zip",
              destfile = here("output/ghsl.zip"))
  # extract
  archive_extract(here("output/ghsl.zip"),
                  here("output/ghsl"))
  # crop and save
  here("output/ghsl/GHS_BUILT_LDS2014_GLOBE_R2016A_54009_250_v1_0/GHS_BUILT_LDS2014_GLOBE_R2016A_54009_250_v1_0.tif") |> 
    raster::raster() |> 
    raster::crop(tanzania_whole |> st_transform("ESRI:54009")) |> 
    raster::mask(tanzania_whole |> st_transform("ESRI:54009")) |> 
    raster::writeRaster(here("output/ghsl.tif"), overwrite = TRUE)
} 
```

```{r}
#| label: load-ghsl

ghsl <- here("output/ghsl.tif") |> 
  terra::rast() |> 
  terra::project("epsg:4326")
```


```{r}
#| label: fig-zonal-ghsl
#| fig-cap: Zonal statistics for GHSL

ghsl_zonal <- ghsl |> 
  zonal(tanzania_vect, fun = "mean", na.rm = TRUE) |> 
  cbind(tanzania |> dplyr::select(name)) |> 
  st_as_sf()

basemap +
  geom_sf(data = ghsl_zonal,
          aes(fill = log(ghsl + 0.000001))) +
  labs(fill = "log Global Human \nSettlement Layer",
       caption = "Data: European Commission")

basemap + 
  geom_raster(data = ghsl |> as.data.frame(xy = TRUE),
              aes(x = x,
                  y = y,
                  fill = log(ghsl + 0.000001))) +
    labs(fill = "log Global Human \nSettlement Layer",
       caption = "Data: European Commission")

```


# Aggregating data on nighttime light grid level

I use the nighttime light grid as a baseline grid.
To calculate the overlap with the other data sets, I convert it from raster to an `sf` data frame.
This makes it easier to calculate the overlap; additionally, for the regression, I need a data frame.

To determine if there is an antenna on the grid, I intersect the antenna point layer with this baseline grid.
I use the function `zonal` from the `terra` package to aggregate all other raster data on this level.
I use the mean and ignore `NA`s.

```{r}
#| label: add-state-to-nightlights

if (!"nightlights_sf_w_state.rds" %in% (here("output") |> list.files())) {
  # intersect first
  nightlights_state_intersection <- nightlights_sf |>  
    st_intersects(tanzania |> dplyr::select(name))
  
  # figure out number of overlapping states, and pull out first
  overlap_state_number <- nightlights_state_intersection %>% lengths()
  overlap_first <- sapply(nightlights_state_intersection, first, default = NA)
  
  # determine the final state
  nightlights_state <- data.frame(state = overlap_first,
                           number_states = overlap_state_number) |> 
    mutate(state_name = case_when(number_states == 0 ~ "none",
                                  number_states == 1 ~ tanzania$name[state],
                                  number_states > 1 ~ "multiple states")) |> 
    mutate(state_name = labelled(state_name, label = "State name"))
  
  
  saveRDS(nightlights_state,
          here("output/nightlights_states.rds"))
} else {
  nightlights_state <-
    here("output/nightlights_states.rds") |> readRDS()
}

```


```{r}
#| label: count-antennas-per-grid-cell

if (!("ntl_antennas_vector.rds" %in% (here("output") |> list.files()))) {
  ntl_antennas <- st_intersects(nightlights_sf, open_cell)
  
  ntl_antennas_vector <- ntl_antennas %>% lengths
  
  saveRDS(ntl_antennas,
          here("output/ntl_antennas_sgbp.rds"))
  saveRDS(ntl_antennas_vector,
          here("output/ntl_antennas_vector.rds"))
} else {
  ntl_antennas_vector <-
    here("output/ntl_antennas_vector.rds") |> readRDS()
}

# per technology
if (! all(c("ntl_two_g.rds", "ntl_three_g.rds", "ntl_four_g.rds") %in%
          (here("output") |> list.files()))) {
  
ntl_two_g <- st_intersects(nightlights_sf, two_g) %>% lengths
ntl_three_g <- st_intersects(nightlights_sf, three_g) %>% lengths
ntl_four_g <- st_intersects(nightlights_sf, four_g) %>% lengths

saveRDS(ntl_two_g, here("output/ntl_two_g.rds"))
saveRDS(ntl_three_g, here("output/ntl_three_g.rds"))
saveRDS(ntl_four_g, here("output/ntl_four_g.rds"))
} else {
  ntl_two_g <- here("output/ntl_two_g.rds") |> readRDS()
  ntl_three_g <- here("output/ntl_three_g.rds") |> readRDS()
  ntl_four_g <- here("output/ntl_four_g.rds") |> readRDS()
}

```


```{r}
#| label: calculate-ntl-zonal-statistics

if (! "ntl_lightnings_zonal.rds" %in% (here("output") |> list.files())) {
  ntl_lightnings_zonal <- zonal(lightning,
                                nightlights_vect,
                                fun = "mean",
                                na.rm = TRUE)
  saveRDS(ntl_lightnings_zonal,
          here("output/ntl_lightnings_zonal.rds"))
} else {
  ntl_lightnings_zonal <- here("output/ntl_lightnings_zonal.rds") |> readRDS()
}

```

```{r}
#| label: calculate-tri-zonal-statistics

if (! "ntl_tri_zonal.rds" %in% (here("output") |> list.files())) {
  ntl_tri_zonal <- zonal(tri,
                                nightlights_vect,
                                fun = "mean", na.rm = TRUE)
  
  saveRDS(ntl_tri_zonal,
          here("output/ntl_tri_zonal.rds"))
  
} else {
  ntl_tri_zonal <-
    here("output/ntl_tri_zonal.rds") |> readRDS()
}
```

```{r}
#| label: calculate-ghsl-zonal-statistics

if (! "ntl_ghsl_zonal.rds" %in% (here("output") |> list.files())) {
  ntl_ghsl_zonal <- zonal(ghsl,
                                 nightlights_vect,
                                 fun = "mean", na.rm = TRUE)
  
  saveRDS(ntl_ghsl_zonal,
          here("output/ntl_ghsl_zonal.rds"))
} else {
  ntl_ghsl_zonal <- here("output/ntl_ghsl_zonal.rds") |> readRDS()
}
```

```{r}
#| label: add-lat-lon

if (! "centroids.rds" %in% (here("output") |> list.files())) {
  
# add an x and y coordinate variable for Conley SE
centroids <- nightlights_sf |> 
  dplyr::select(geometry) |> 
  st_as_sf() |> 
  st_centroid() |> 
  st_coordinates() |> 
  as.data.frame() |> 
  rename(lat = X,
         lon = Y)

saveRDS(centroids,
        here("output/centroids.rds"))
} else {
  centroids <- here("output/centroids.rds") |> readRDS()
}

```


```{r}
#| label: gather-statistics

data <- nightlights_sf |>
  cbind(nightlights_state |> dplyr::select(state_name)) |> 
  cbind(ntl_lightnings_zonal) |>
  cbind(ntl_tri_zonal) |>
  cbind(ntl_ghsl_zonal) |>
  cbind(centroids) |> 
  # add pretty labels
  mutate(
    DN_NTL_2021 = labelled(DN_NTL_2021, label = "Mean night time lights"),
    lightnings_tanzania = labelled(lightnings_tanzania,   
                                   label = "Mean number of lightnings"),
    tri_tanzania = labelled(tri_tanzania, label = "Mean TRI"),
    ghsl = labelled(ghsl, label = "Mean GHSL")
  ) |>
  # add antenna info
  mutate(number_antennas = labelled(ntl_antennas_vector,
                                    label = "Number of antennas")) |>
  mutate(log_number_antennas = labelled(log(ntl_antennas_vector + 1e-10),
                                        label = "Log number of antennas")) |>
  mutate(
    number_2g = labelled(ntl_two_g, label = "Number of 2G antennas"),
    number_3g = labelled(ntl_three_g, label = "Number of 3G antennas"),
    number_4g = labelled(ntl_four_g, label = "Number of 4G antennas"),
    any_2g = labelled(as.integer(ntl_two_g > 0), label = "Any 2G antenna"),
    any_3g = labelled(as.integer(ntl_three_g > 0), label = "Any 3G antenna"),
    any_4g = labelled(as.integer(ntl_four_g > 0), label = "Any 4G antenna"),
  ) 

```

```{r}
#| label: tbl-one
#| tbl-cap: Summary statistics

selected_cols <- data |> 
  as.data.frame() |> 
  dplyr::select(-geometry, -lon, -lat, -state_name) |> 
  names()

# prepare histogram sparklines
tmp_list <- data |> 
  as.data.frame() |> 
  dplyr::select(all_of(selected_cols)) |>
  lapply(na.omit) |> 
  lapply(scale)

# formatting things
emptycol <- function(x) " "
f <- function(x) format(round(x, 2), big.mark=",")
# formula
formula_summary <- paste(
  paste(paste0(selected_cols), collapse = "+"), 
  '~ N + Mean + SD + Median + Min + Max + Heading("Histogram") * emptycol'
  )

datasummary(formula = as.formula(formula_summary),
            data = data,
            format = f,
            output = "data.frame",
            notes = "Unit of observation: Nighttime lights grid cell") |> 
  kbl(booktabs = TRUE,
      align = c("l", rep("r", 6), "c")) |> 
  column_spec(column = 8, image = spec_hist(tmp_list)) |> 
  pack_rows("Explanatory variables", 1, 4) |> 
  pack_rows("Dependent variables", 5, 12)
```

@tbl-one shows the summary statistics for the aggregated data set.
It's worth taking a moment to analyse the antennas per grid cell. 
As @fig-raster-antennas shows, many grid cells have no antenna; a few have many, with a maximum of `r data$number_antennas |> max()`.
However, the grid cells with the many antennas align with the pattern we have seen in @fig-antennas, so that can easily be explained. 
```{r}
#| label: fig-raster-antennas
#| fig-cap: "Antennas per grid cell"
#| fig-subcap: 
#|   - "Histogram"
#|   - "Map"

number_antennas_raster <- data |> 
  dplyr::select(log_number_antennas) |> 
  st_rasterize() |> 
  as.data.frame(xy = TRUE)

ggplot() +
  geom_histogram(data = data,
            aes(x = number_antennas),
            bins = 50) +
  scale_y_continuous(trans = scales::pseudo_log_trans()) +
  theme_minimal() +
  labs(x = "Log number of antennas per grid cell")

basemap +
  geom_raster(data = number_antennas_raster,
              aes(x = x,
                  y = y,
                  fill = log_number_antennas)) +
  scale_fill_continuous(na.value = NA) +
  labs(fill = "Log number of antennas")
```

# Regressions

In run seperate regressions for each technology.
Within each technology, I use two different dependent variables: 

-   any antenna in grid cell
-   number of antennas per grid cell

The first specification is due to the wording in the homework assignment; the second is because I noticed some cells with much larger values than 1.

For each of these dependent variables, I run the following regressions:

1.    *baseline:* a simple ordinary least squares regression (OLS) 
2.    *fixed effects (FE)*: a simple OLS with FE on the state level, and accordingly clustered standard errors
3.    *HAC standard errors:* as 2., but with standard errors accounting for heteroscedasticity.

I also considered using *Conley standard errors*. 
However, the regressions took too long to run. 
If of interest, it can however be run in the cells `run-regression-2g` to `run-regression-4g` by adding the following argument to the function `run_regressions`: `conley = TRUE`. 

I decide against using an instrumental variables (IV) approach.
This is because while lightning strikes are an instrument for mobile antennas, mobile antennas in this case are the dependent variable. 
However, the IV approach is only used when there is an endogenous explanatory variable.
Since this is not the case, and I do not know of any further endogeneity issues or how to solve them through IV, I do not employ an IV strategy.

```{r}
#| label: declare-explanatory-vals

explanatory_vals <- c("DN_NTL_2021", 
                      "lightnings_tanzania", 
                      "tri_tanzania", 
                      "ghsl")
```


## 2G (GMS)

In the first set of regressions, I consider 2G antennas, i.e. the earliest ones. 
As seen in @fig-antennas, this type of antenna is the most frequent one. 
With this type of antenna, we should be able to see how the government chooses spots for early and basic provision.
@tbl-

```{r}
#| label: run-regression-2g

reg_bin_2g <- run_regressions("any_2g")
reg_2g <- run_regressions("number_2g")
```

```{r}
#| label: tbl-regression-2g
#| tbl-cap: Regression results for 2G antennas

list(
  "Dependent variable: any 2G antenna" = reg_bin_2g,
  "Dependent variable: number of 2G antennas" = reg_2g
) |>
  show_regressions(regression_list = _)

```


## 3G (UMTS)

```{r}
#| label: run-regressions-3g

reg_bin_3g <- run_regressions("any_3g")
reg_3g <- run_regressions("number_3g")

```
```{r}
#| label: tbl-regressions-3g
#| tbl-cap: Regression results for 3G antennas

list(
  "Dependent variable: any 3G antenna" = reg_bin_3g,
  "Dependent variable: number of 3G antennas" = reg_3g
) |>
  show_regressions(regression_list = _)
```


## 4G (LTE)
```{r}
#| label: run-regressions-4g
reg_bin_4g <- run_regressions("any_4g")
reg_4g <- run_regressions("number_4g")
```
```{r}
#| label: tbl-regressions-4g
#| tbl-cap: Regression results for 4G antennas

list(
  "Dependent variable: any 4G antenna" = reg_bin_4g,
  "Dependent variable: number of 4G antennas" = reg_4g
) |>
  show_regressions(regression_list = _)
```

# Discussion and conclusion

{{< pagebreak >}}

# References {.unnumbered}